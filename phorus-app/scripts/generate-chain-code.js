#!/usr/bin/env node

/**
 * Script to generate TypeScript code for all LiFi chains
 * Reads lifi-chains.json and generates chain definitions
 */

const fs = require('fs')
const path = require('path')

const CHAINS_FILE = path.join(__dirname, 'lifi-chains.json')
const OUTPUT_FILE = path.join(__dirname, 'generated-chains.ts')

// Common chain configurations from wagmi/chains that we want to use if available
const WAGMI_CHAINS = {
  1: 'mainnet',
  42161: 'arbitrum',
  10: 'optimism',
  8453: 'base',
  137: 'polygon',
  43114: 'avalanche',
  56: 'bsc',
  250: 'fantom',
  100: 'gnosis',
  42220: 'celo',
  1666600000: 'harmony',
  1284: 'moonbeam',
  1285: 'moonriver',
  25: 'cronos',
  1101: 'polygonZkEvm',
  324: 'zksync',
  59144: 'linea',
  5000: 'mantle',
  534352: 'scroll',
  204: 'opBNB',
  81457: 'blast',
  169: 'manta',
  1337: 'hyperliquid', // Custom - will be defined separately
}

// Chain ID to name mapping for display
const CHAIN_NAMES = {
  1: 'Ethereum',
  42161: 'Arbitrum',
  10: 'Optimism',
  8453: 'Base',
  137: 'Polygon',
  43114: 'Avalanche',
  56: 'BNB Chain',
  250: 'Fantom',
  100: 'Gnosis',
  42220: 'Celo',
  1666600000: 'Harmony',
  1284: 'Moonbeam',
  1285: 'Moonriver',
  25: 'Cronos',
  1101: 'Polygon zkEVM',
  324: 'zkSync Era',
  59144: 'Linea',
  5000: 'Mantle',
  534352: 'Scroll',
  204: 'opBNB',
  81457: 'Blast',
  169: 'Manta',
  37714555429: 'Saakuru',
  1337: 'Hyperliquid',
}

function generateChainCode() {
  if (!fs.existsSync(CHAINS_FILE)) {
    console.error(`❌ Chains file not found: ${CHAINS_FILE}`)
    console.error('Please run fetch-lifi-chains.js first')
    process.exit(1)
  }

  const chainsData = JSON.parse(fs.readFileSync(CHAINS_FILE, 'utf8'))
  
  // Handle both array format and object format
  const chainsArray = Array.isArray(chainsData) 
    ? chainsData 
    : Object.entries(chainsData).map(([key, value]) => ({
        key,
        ...value,
      }))
  
  // Sort by chain ID (use 'id' field from LiFi API)
  const chains = chainsArray.map(chain => ({
    key: chain.key,
    chainId: chain.id || chain.chainId,
    name: chain.name,
    nativeCurrency: chain.metamask?.nativeCurrency || chain.nativeCurrency,
    rpcUrls: chain.metamask?.rpcUrls || chain.rpcUrls,
    blockExplorers: chain.metamask?.blockExplorerUrls ? {
      default: {
        name: chain.name + ' Explorer',
        url: chain.metamask.blockExplorerUrls[0]
      }
    } : chain.blockExplorers,
  })).sort((a, b) => a.chainId - b.chainId)

  console.log(`Generating code for ${chains.length} chains...`)

  // Collect all wagmi chains we'll use
  const usedWagmiChains = new Set()
  chains.forEach(chain => {
    const wagmiName = WAGMI_CHAINS[chain.chainId]
    if (wagmiName && wagmiName !== 'hyperliquid') {
      usedWagmiChains.add(wagmiName)
    }
  })

  let code = `// Auto-generated chain definitions from LiFi API
// Do not edit this file manually - run generate-chain-code.js instead

import { defineChain } from 'viem'
${Array.from(usedWagmiChains).map(name => {
    // Map wagmi chain names to their import names
    const wagmiImport = name === 'polygon' ? 'polygon' : 
                       name === 'bsc' ? 'bsc' :
                       name === 'fantom' ? 'fantom' :
                       name === 'gnosis' ? 'gnosis' :
                       name === 'celo' ? 'celo' :
                       name === 'harmony' ? 'harmony' :
                       name === 'moonbeam' ? 'moonbeam' :
                       name === 'moonriver' ? 'moonriver' :
                       name === 'cronos' ? 'cronos' :
                       name === 'polygonZkEvm' ? 'polygonZkEvm' :
                       name === 'zksync' ? 'zksync' :
                       name === 'linea' ? 'linea' :
                       name === 'mantle' ? 'mantle' :
                       name === 'scroll' ? 'scroll' :
                       name === 'opBNB' ? 'opBNB' :
                       name === 'blast' ? 'blast' :
                       name === 'manta' ? 'manta' :
                       name
    return `import { ${wagmiImport} } from 'wagmi/chains'`
  }).join('\n')}

// Custom chain definitions for chains not in wagmi/chains
`

  // Generate chain definitions
  const chainDefinitions = []
  const chainIdToKey = {}
  const chainImports = new Set()

  chains.forEach(chain => {
    const chainId = chain.chainId
    const wagmiChainName = WAGMI_CHAINS[chainId]
    
    // Create a safe key name from LiFi key
    const keyName = chain.key || `chain_${chainId}`
    chainIdToKey[chainId] = keyName

    if (wagmiChainName && wagmiChainName !== 'hyperliquid') {
      // Use wagmi chain if available, but add lifiKey property (keep numeric id for Wagmi)
      chainImports.add(wagmiChainName)
      chainDefinitions.push(`  ${keyName}: Object.assign({}, ${wagmiChainName}, { lifiKey: '${keyName}' }),`)
    } else {
      // Generate custom chain definition
      const name = chain.name || `Chain ${chainId}`
      const nativeCurrency = chain.nativeCurrency || {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18
      }
      
      // Handle RPC URLs - could be array or object
      let rpcUrl = null
      if (Array.isArray(chain.rpcUrls)) {
        rpcUrl = chain.rpcUrls[0]
      } else if (chain.rpcUrls?.default?.http) {
        rpcUrl = Array.isArray(chain.rpcUrls.default.http) 
          ? chain.rpcUrls.default.http[0]
          : chain.rpcUrls.default.http
      } else if (typeof chain.rpcUrls === 'string') {
        rpcUrl = chain.rpcUrls
      }
      
      // Handle block explorers
      let explorerUrl = null
      let explorerName = null
      if (chain.blockExplorers?.default?.url) {
        explorerUrl = chain.blockExplorers.default.url
        explorerName = chain.blockExplorers.default.name || `${name} Explorer`
      } else if (Array.isArray(chain.blockExplorers)) {
        explorerUrl = chain.blockExplorers[0]
      }
      
      let chainDef = `  ${keyName}: Object.assign({}, defineChain({\n`
      chainDef += `    id: ${chainId},\n`
      chainDef += `    name: '${name.replace(/'/g, "\\'")}',\n`
      chainDef += `    nativeCurrency: {\n`
      chainDef += `      name: '${(nativeCurrency.name || 'Ether').replace(/'/g, "\\'")}',\n`
      chainDef += `      symbol: '${(nativeCurrency.symbol || 'ETH').replace(/'/g, "\\'")}',\n`
      chainDef += `      decimals: ${nativeCurrency.decimals || 18},\n`
      chainDef += `    },\n`
      
      if (rpcUrl) {
        chainDef += `    rpcUrls: {\n`
        chainDef += `      default: {\n`
        chainDef += `        http: ['${rpcUrl}'],\n`
        chainDef += `      },\n`
        chainDef += `    },\n`
      }
      
      if (explorerUrl) {
        chainDef += `    blockExplorers: {\n`
        chainDef += `      default: {\n`
        chainDef += `        name: '${(explorerName || 'Explorer').replace(/'/g, "\\'")}',\n`
        chainDef += `        url: '${explorerUrl}',\n`
        chainDef += `      },\n`
        chainDef += `    },\n`
      }
      
      chainDef += `  }), { lifiKey: '${keyName}' }),`
      chainDefinitions.push(chainDef)
    }
  })

  code += `export const allChains = {\n${chainDefinitions.join('\n\n')}\n}\n\n`
  
  // Generate chain ID mapping
  code += `// Chain ID to key mapping\n`
  code += `export const CHAIN_ID_TO_KEY: Record<number, string> = {\n`
  Object.entries(chainIdToKey).forEach(([id, key]) => {
    code += `  ${id}: '${key}',\n`
  })
  code += `}\n\n`
  
  // Generate reverse mapping (key to chain ID)
  code += `// Key to chain ID mapping\n`
  code += `export const KEY_TO_CHAIN_ID: Record<string, number> = {\n`
  Object.entries(chainIdToKey).forEach(([id, key]) => {
    code += `  '${key}': ${id},\n`
  })
  code += `}\n\n`
  
  // Generate array of all chains for Wagmi
  code += `// Array of all chains for Wagmi\n`
  code += `export const chainsArray = Object.values(allChains)\n`

  fs.writeFileSync(OUTPUT_FILE, code)
  console.log(`✅ Generated chain code to ${OUTPUT_FILE}`)
  console.log(`   Total chains: ${chains.length}`)
  console.log(`   Wagmi chains: ${chainImports.size}`)
  console.log(`   Custom chains: ${chains.length - chainImports.size}`)
}

generateChainCode()
